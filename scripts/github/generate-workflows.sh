#!/usr/bin/env bash
# Regenerates lightweight wrapper workflows from platforms.yaml

set -euo pipefail

# -----------------------------------------------------------------------------------
# Function: resolve_script_dir
# Purpose : Resolves the absolute path of the script's directory, handling symlinks.
# Returns :
#   Exports SOURCE, SCRIPT_DIR
# Note    : This function relies on BASH_SOURCE, so it must be used in a Bash shell.
# -----------------------------------------------------------------------------------
resolve_script_dir() {
    local source="${BASH_SOURCE[0]}"

    # Follow symbolic links until we get the real file location
    while [ -L "${source}" ]; do
        # Get the directory path where the symlink is located
        dir="$(cd -P "$(dirname "${source}")" >/dev/null 2>&1 && pwd)"
        # Use readlink to get the target the symlink points to
        source="$(readlink "${source}")"
        # If the source was a relative symlink, convert it to an absolute path
        [[ "${source}" != /* ]] && source="${dir}/${source}"
    done

    # After resolving symlinks, retrieve the directory of the final source
    SCRIPT_DIR="$(cd -P "$(dirname "${source}")" >/dev/null 2>&1 && pwd)"

    # Exports
    export SOURCE="${source}"
    export SCRIPT_DIR="${SCRIPT_DIR}"
}

# -----------------------------------------------------------------------------------
# Function: initialize_environment
# Purpose :
#   1) Resolve the script's directory.
#   2) Change into that directory plus an optional subdirectory (if provided).
#   3) Export ENV_ROOT as the new working directory.
#   4) Source a utility script (`utils.sh`) with optional version parameters.
#
# Arguments:
#   1) $1 - Relative or absolute path to a subdirectory (optional).
#           If omitted or empty, defaults to '.' (the same directory as resolve_script_dir).
#
# Usage Example:
#   initialize_environment        # Uses the script's directory
#   initialize_environment "dev"  # Changes to script's directory + "/dev"
# -----------------------------------------------------------------------------------
initialize_environment() {
    # Resolve script's directory
    resolve_script_dir

    # Local variables
    local subdir
    # Check if a subdirectory argument was passed; default to '.' if not
    subdir="${1:-.}"

    # Attempt to change into the resolved directory + the subdirectory
    if cd "${SCRIPT_DIR}/${subdir}"; then
        ENV_ROOT="$(pwd)"
        export ENV_ROOT
    else
        printf "Error: %s\n" "Failed to change directory to '${SCRIPT_DIR}/${subdir}'." >&2 && exit 1
    fi
}

abbr_platform() {
  case "$1" in
    nextcloud)      printf "nc"     ;;
    nextcloud-sm)   printf "nc-sm"  ;;
    owncloud)       printf "oc"     ;;
    owncloud-sm)    printf "oc-sm"  ;;
    ocis)           printf "ocis"   ;;
    opencloud)      printf "opcl"   ;;
    ocmstub)        printf "os"     ;;
    seafile)        printf "sf"     ;;
    *)              printf "%s" "${1:0:2}" ;;
  esac
}

abbr_version() {
  local major
  major="$(sed -E 's/^v?([0-9]+).*/\1/' <<< "$1")"
  printf "v%s" "$major"
}

# title-case helper (unchanged after previous fix)
titlecase() { printf '%s' "${1^}"; }

# -----------------------------------------------------------------------------------
# Function: main
# Purpose: Main function to manage the flow of the script.
# -----------------------------------------------------------------------------------
main() {
    # Initialize environment.
    initialize_environment "../.."

    local config_file="${ENV_ROOT}/scripts/github/config/platforms.yaml"
    local workflows="${ENV_ROOT}/.github/workflows"

    # Only delete files generated by this script â€“ keep the engine, orchestrator, pages etc.
    find "$workflows" -maxdepth 1 -type f -regextype posix-extended \
        -regex ".*/(login|share-link|share-with|invite-link).*\.yml" -delete

    # Iterate over top-level keys in the YAML
    for scenario in $(yq e 'keys | .[]' "$config_file"); do
        if [[ "$scenario" == "login" ]]; then
            # One-column variant
            yq e ".${scenario}[]" "$config_file" -o=json | jq -c '.' | while read -r row; do
                platform=$(jq -r '.platform' <<<"$row")
                version=$(jq -r '.version' <<<"$row")
                file="${workflows}/login-$(abbr_platform "$platform")-$(abbr_version "$version").yml"

                cat >"$file" <<EOF
name: OCM Test Login $(titlecase "$platform") ${version}

on:
  workflow_dispatch:

jobs:
  call-test-engine:
    uses: ./.github/workflows/tests-engine.yml
    with:
      scenario:          login
      sender_platform:   ${platform}
      sender_version:    ${version}
EOF
            done
        else
            # Two-party scenarios
            yq e ".${scenario}[]" "$config_file" -o=json | jq -c '.' | while read -r row; do
                s_platform=$(jq -r '.sender.platform' <<<"$row")
                s_version=$(jq -r '.sender.version' <<<"$row")
                r_platform=$(jq -r '.receiver.platform' <<<"$row")
                r_version=$(jq -r '.receiver.version' <<<"$row")

                file="${workflows}/${scenario}-$(abbr_platform "$s_platform")-$(abbr_version "$s_version")-$(abbr_platform "$r_platform")-$(abbr_version "$r_version").yml"
                scenoname=$(titlecase "${scenario/-/ }") # share-link to Share Link

                cat >"$file" <<EOF
name: OCM Test ${scenoname} $(titlecase "$s_platform") ${s_version} to $(titlecase "$r_platform") ${r_version}

on:
  workflow_dispatch:

jobs:
  call-test-engine:
    uses: ./.github/workflows/tests-engine.yml
    with:
      scenario:          ${scenario}
      sender_platform:   ${s_platform}
      sender_version:    ${s_version}
      receiver_platform: ${r_platform}
      receiver_version:  ${r_version}
EOF
            done
        fi
    done
}

# -----------------------------------------------------------------------------------
# Execute the main function with passed arguments
# -----------------------------------------------------------------------------------
main "$@"
