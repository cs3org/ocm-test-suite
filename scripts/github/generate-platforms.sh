#!/usr/bin/env bash
# Expands platform_rules.yaml into platforms.yaml

set -euo pipefail

# -----------------------------------------------------------------------------------
# Function: resolve_script_dir
# Purpose : Resolves the absolute path of the script's directory, handling symlinks.
# Returns :
#   Exports SOURCE, SCRIPT_DIR
# Note    : This function relies on BASH_SOURCE, so it must be used in a Bash shell.
# -----------------------------------------------------------------------------------
resolve_script_dir() {
    local source="${BASH_SOURCE[0]}"

    # Follow symbolic links until we get the real file location
    while [ -L "${source}" ]; do
        # Get the directory path where the symlink is located
        dir="$(cd -P "$(dirname "${source}")" >/dev/null 2>&1 && pwd)"
        # Use readlink to get the target the symlink points to
        source="$(readlink "${source}")"
        # If the source was a relative symlink, convert it to an absolute path
        [[ "${source}" != /* ]] && source="${dir}/${source}"
    done

    # After resolving symlinks, retrieve the directory of the final source
    SCRIPT_DIR="$(cd -P "$(dirname "${source}")" >/dev/null 2>&1 && pwd)"

    # Exports
    export SOURCE="${source}"
    export SCRIPT_DIR="${SCRIPT_DIR}"
}

# -----------------------------------------------------------------------------------
# Function: initialize_environment
# Purpose :
#   1) Resolve the script's directory.
#   2) Change into that directory plus an optional subdirectory (if provided).
#   3) Export ENV_ROOT as the new working directory.
#   4) Source a utility script (`utils.sh`) with optional version parameters.
#
# Arguments:
#   1) $1 - Relative or absolute path to a subdirectory (optional).
#           If omitted or empty, defaults to '.' (the same directory as resolve_script_dir).
#
# Usage Example:
#   initialize_environment        # Uses the script's directory
#   initialize_environment "dev"  # Changes to script's directory + "/dev"
# -----------------------------------------------------------------------------------
initialize_environment() {
    # Resolve script's directory
    resolve_script_dir

    # Local variables
    local subdir
    # Check if a subdirectory argument was passed; default to '.' if not
    subdir="${1:-.}"

    # Attempt to change into the resolved directory + the subdirectory
    if cd "${SCRIPT_DIR}/${subdir}"; then
        ENV_ROOT="$(pwd)"
        export ENV_ROOT
    else
        printf "Error: %s\n" "Failed to change directory to '${SCRIPT_DIR}/${subdir}'." >&2 && exit 1
    fi
}

yq_get() { yq e "$1" "$rules_file"; }
# turn YAML seq into bash array
to_array() { mapfile -t "$1"; }

# write a YAML map-in-flow-style:  { key: val, key2: val2 }
flow_map() {
    local sep=""
    printf "{ "
    while (("$#")); do
        printf "%s%s: %s" "$sep" "$1" "$2"
        sep=", "
        shift 2
    done
    printf " }"
}

# -----------------------------------------------------------------------------------
# Function: main
# Purpose: Main function to manage the flow of the script.
# -----------------------------------------------------------------------------------
main() {
    # Initialize environment.
    initialize_environment "../.."

    local rules_file="${ENV_ROOT}/scripts/github/config/platform_rules.yaml"
    local output_file="${ENV_ROOT}/scripts/github/config/platforms.yaml"

    to_array PLATFORM_NAMES < <(yq_get '.platforms | keys | .[]')
    to_array SCENARIOS < <(yq_get '.scenarios | keys | .[]')

    {
        echo "# -----------------------------------------------------------------"
        echo "# Auto-generated by generate-platforms.sh — DO NOT EDIT BY HAND"
        echo "# -----------------------------------------------------------------"

        for scen in "${SCENARIOS[@]}"; do
            echo
            echo "${scen}:"

            if [[ "$scen" == "login" ]]; then
                to_array INCLUDE < <(yq_get ".scenarios.login.include[]")
                [[ "${INCLUDE[*]}" == "*" ]] && INCLUDE=("${PLATFORM_NAMES[@]}")

                for plat in "${INCLUDE[@]}"; do
                    to_array VERS < <(yq_get ".platforms.${plat}[]")
                    for ver in "${VERS[@]}"; do
                        echo "  - $(flow_map platform ${plat} version ${ver})"
                    done
                done

            else
                LEN=$(yq_get ".scenarios.${scen}.include | length")
                for ((i = 0; i < LEN; i++)); do
                    to_array SENDERS < <(yq_get ".scenarios.${scen}.include[$i].sender[]")
                    to_array RECEIVERS < <(yq_get ".scenarios.${scen}.include[$i].receiver[]")

                    [[ "${SENDERS[*]}" == "*" ]] && SENDERS=("${PLATFORM_NAMES[@]}")
                    [[ "${RECEIVERS[*]}" == "*" ]] && RECEIVERS=("${PLATFORM_NAMES[@]}")

                    for sp in "${SENDERS[@]}"; do
                        for rp in "${RECEIVERS[@]}"; do
                            to_array SP_VERS < <(yq_get ".platforms.${sp}[]")
                            to_array RP_VERS < <(yq_get ".platforms.${rp}[]")

                            for sv in "${SP_VERS[@]}"; do
                                for rv in "${RP_VERS[@]}"; do
                                    echo "  - $(flow_map \
                                        sender "$(flow_map platform ${sp} version ${sv})" \
                                        receiver "$(flow_map platform ${rp} version ${rv})")"
                                done
                            done
                        done
                    done
                done
            fi
        done
    } >"${output_file}.tmp"

    mv "${output_file}.tmp" "${output_file}"
    echo "✅  Generated ${output_file}"
}

# -----------------------------------------------------------------------------------
# Execute the main function with passed arguments
# -----------------------------------------------------------------------------------
main "$@"
